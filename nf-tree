#!/usr/bin/python3
import os
import sys
import subprocess
import argparse
import time
from datetime import datetime

SNAPSHOT_BASE = "/nf-tree/snapshots"
AUTO_DIR = os.path.join(SNAPSHOT_BASE, "auto")
MANUAL_DIR = os.path.join(SNAPSHOT_BASE, "manual")
ROOT_SOURCE = "/"
HOME_SOURCE = "/home"

def setup_dirs():
    if not os.path.exists(AUTO_DIR):
        os.makedirs(AUTO_DIR)
    if not os.path.exists(MANUAL_DIR):
        os.makedirs(MANUAL_DIR)

def run_cmd(command):
    try:
        result = subprocess.run(command, check=False, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
        if result.returncode == 0:
            return True
        else:
            print(f"Error executing {' '.join(command)}:")
            print(result.stderr.decode('utf-8'))
            return False
    except Exception as e:
        print(f"Execution failed: {e}")
        return False

def update_grub():
    print("Updating GRUB...")
    subprocess.run(["update-grub"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)

def check_changes(path, last_snapshot_time):
    exclude = {'proc', 'sys', 'dev', 'run', 'tmp', 'var', 'mnt', 'media', 'nf-tree', '.snapshots', 'swapfile'}
    for root, dirs, files in os.walk(path):
        dirs[:] = [d for d in dirs if d not in exclude]
        for file in files:
            try:
                full_path = os.path.join(root, file)
                if os.path.islink(full_path):
                    continue
                if os.path.getmtime(full_path) > last_snapshot_time:
                    return True
            except OSError:
                continue
    return False

def toggle_swap(active):
    if not active:
        subprocess.run(["swapoff", "-a"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
    else:
        if os.path.exists("/dev/zram0"):
            subprocess.run(["mkswap", "/dev/zram0"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
            subprocess.run(["swapon", "/dev/zram0", "-p", "100"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        else:
            subprocess.run(["swapon", "-a"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)

def cleanup_retention(base_name):
    try:
        snapshots = [s for s in os.listdir(AUTO_DIR) if s.startswith(base_name)]
        snapshots.sort()

        if len(snapshots) > 6:
            to_remove = snapshots[:-6]
            for snap in to_remove:
                full_path = os.path.join(AUTO_DIR, snap)
                subprocess.run(["btrfs", "subvolume", "delete", full_path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                print(f"Auto-removed old snapshot: {snap}")
    except OSError:
        pass

def create_snapshot(source, name, is_auto=False):
    setup_dirs()

    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    target_name = f"{name}-{timestamp}"

    target_dir = AUTO_DIR if is_auto else MANUAL_DIR
    target_path = os.path.join(target_dir, target_name)

    if os.path.exists(target_path):
        if not is_auto:
            print(f"Error: Snapshot {target_name} already exists.")
            return

    subprocess.run(["sync"], check=False)

    is_root = (source == ROOT_SOURCE)

    if is_root:
        toggle_swap(False)

    try:
        cmd = ["btrfs", "subvolume", "snapshot", source, target_path]
        if run_cmd(cmd):
            print(f"Created: {target_path}")
            if is_auto:
                cleanup_retention(name)
            update_grub()
        else:
            print(f"Failed: {target_name}")
    finally:
        if is_root:
            toggle_swap(True)

def remove_snapshot(name):
    path_auto = os.path.join(AUTO_DIR, name)
    path_manual = os.path.join(MANUAL_DIR, name)

    target_path = None
    if os.path.exists(path_manual):
        target_path = path_manual
    elif os.path.exists(path_auto):
        target_path = path_auto

    if target_path:
        cmd = ["btrfs", "subvolume", "delete", target_path]
        if run_cmd(cmd):
            print(f"Removed: {target_path}")
            update_grub()
        else:
            print(f"Error removing: {target_path}")
    else:
        print(f"Error: Snapshot {name} not found in auto or manual directories.")

def daemon_loop():
    print("NF-Tree Daemon started...")
    last_run = time.time()

    while True:
        current_time = time.time()

        if check_changes(HOME_SOURCE, last_run):
            create_snapshot(HOME_SOURCE, "home-auto", is_auto=True)

        if check_changes(ROOT_SOURCE, last_run):
            create_snapshot(ROOT_SOURCE, "root-auto", is_auto=True)

        last_run = current_time
        time.sleep(10800)

def main():
    parser = argparse.ArgumentParser(description="NF-Tree Snapshot Manager")
    subparsers = parser.add_subparsers(dest="command")

    create_parser = subparsers.add_parser("create")
    create_parser.add_argument("name", help="Snapshot name prefix")

    remove_parser = subparsers.add_parser("remove")
    remove_parser.add_argument("name", help="Full snapshot folder name to remove")

    daemon_parser = subparsers.add_parser("start-daemon")

    args = parser.parse_args()

    if args.command == "create":
        is_auto_snapshot = args.name.startswith("apt") or args.name == "auto"
        create_snapshot(ROOT_SOURCE, f"root-{args.name}", is_auto=is_auto_snapshot)
        create_snapshot(HOME_SOURCE, f"home-{args.name}", is_auto=is_auto_snapshot)

    elif args.command == "remove":
        remove_snapshot(args.name)

    elif args.command == "start-daemon":
        try:
            daemon_loop()
        except KeyboardInterrupt:
            print("Daemon stopped.")

if __name__ == "__main__":
    if os.geteuid() != 0:
        print("Error: Must run as root")
        sys.exit(1)
    main()
